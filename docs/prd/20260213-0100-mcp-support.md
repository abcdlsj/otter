# Feature: MCP (Model Context Protocol) 支持

## 背景与动机

### 什么是 MCP

MCP (Model Context Protocol) 是由 Anthropic 提出的开放协议，用于标准化 AI 助手与外部工具、数据源的连接方式。它定义了统一的接口，让 AI 能够安全地访问文件系统、数据库、API、浏览器等外部资源。

### 为什么需要这个功能

1. **生态扩展**: MCP 生态正在快速增长，已有数十个官方和社区服务器（PostgreSQL、Browser、GitHub、Slack、Notion 等）
2. **避免重复造轮子**: 无需为每个新功能编写内置工具，直接复用现有 MCP 服务器
3. **标准化**: 遵循行业标准协议，提升互操作性
4. **安全隔离**: MCP 服务器作为独立进程运行，与核心系统隔离
5. **用户价值**: 用户可以通过配置连接任意 MCP 服务器，极大扩展 otter 的能力边界

### 与现有架构的契合

otter 已有成熟的 Tool 接口和注册机制，MCP 支持可以通过适配层无缝集成，无需破坏现有架构。

## 功能描述

### 核心功能

1. **MCP 客户端**: 通过 stdio 或 SSE 与 MCP 服务器通信
2. **工具自动发现**: 动态获取 MCP 服务器提供的工具列表
3. **工具调用**: 将 MCP 工具转换为 otter 内部 Tool 接口
4. **服务器管理**: 配置、启动、停止 MCP 服务器进程
5. **错误处理**: 优雅处理服务器崩溃、超时等情况

### 支持的传输方式

| 传输方式 | 适用场景 | 优先级 |
|---------|---------|-------|
| stdio | 本地服务器进程 | P0 |
| SSE | 远程/云端服务器 | P1 |

### 配置示例

```toml
[[mcp.servers]]
name = "filesystem"
transport = "stdio"
command = "npx"
args = ["-y", "@modelcontextprotocol/server-filesystem", "/home/user/projects"]

[[mcp.servers]]
name = "browser"
transport = "stdio"
command = "npx"
args = ["-y", "@anthropic-ai/mcp-server-browser"]

[[mcp.servers]]
name = "github"
transport = "sse"
url = "https://api.github.com/mcp/sse"
headers = { Authorization = "Bearer ${GITHUB_TOKEN}" }
```

## 技术方案

### 架构设计

```
┌─────────────────────────────────────────────────────────────┐
│                         otter                               │
│  ┌─────────────┐    ┌─────────────┐    ┌─────────────┐     │
│  │   Agent     │───▶│  Tool.Set   │───▶│   Builtin   │     │
│  │             │    │             │    │   Tools     │     │
│  └─────────────┘    │             │    └─────────────┘     │
│                     │             │    ┌─────────────┐     │
│                     │             │───▶│   MCP Tool  │     │
│                     │             │    │   Adapter   │     │
│                     └─────────────┘    └──────┬──────┘     │
│                                               │             │
│                     ┌─────────────────────────┘             │
│                     │                                       │
│                     ▼                                       │
│  ┌────────────────────────────────────────────────────────┐ │
│  │                 MCP Client Manager                      │ │
│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐    │ │
│  │  │   Stdio     │  │    SSE      │  │   Config    │    │ │
│  │  │  Transport  │  │  Transport  │  │   Loader    │    │ │
│  │  └──────┬──────┘  └──────┬──────┘  └─────────────┘    │ │
│  │         │                │                            │ │
│  └─────────┼────────────────┼────────────────────────────┘ │
└────────────┼────────────────┼────────────────────────────────┘
             │                │
             ▼                ▼
     ┌───────────────┐ ┌───────────────┐
     │  MCP Server   │ │  MCP Server   │
     │  (filesystem) │ │  (browser)    │
     └───────────────┘ └───────────────┘
```

### 文件改动

**新增文件:**

```
internal/
├── mcp/
│   ├── client.go          # MCP 客户端核心
│   ├── transport.go       # 传输层接口
│   ├── transport_stdio.go # stdio 传输实现
│   ├── transport_sse.go   # SSE 传输实现
│   ├── protocol.go        # MCP 协议消息定义
│   └── tool_adapter.go    # Tool 接口适配器
```

**修改文件:**

```
internal/
├── config/
│   └── config.go          # 添加 MCP 服务器配置
├── tool/
│   └── tool.go            # 集成 MCP 工具到 Tool.Set
└── tui/
    └── tui.go             # 添加 /mcp 命令
```

### 核心实现细节

#### 1. MCP 协议消息定义

```go
// internal/mcp/protocol.go

type JSONRPCRequest struct {
    JSONRPC string          `json:"jsonrpc"`
    ID      interface{}     `json:"id,omitempty"`
    Method  string          `json:"method"`
    Params  json.RawMessage `json:"params,omitempty"`
}

type JSONRPCResponse struct {
    JSONRPC string          `json:"jsonrpc"`
    ID      interface{}     `json:"id"`
    Result  json.RawMessage `json:"result,omitempty"`
    Error   *JSONRPCError   `json:"error,omitempty"`
}

type Tool struct {
    Name        string          `json:"name"`
    Description string          `json:"description,omitempty"`
    InputSchema json.RawMessage `json:"inputSchema"`
}

type CallToolResult struct {
    Content []ContentItem `json:"content"`
    IsError bool          `json:"isError,omitempty"`
}

type ContentItem struct {
    Type string `json:"type"`
    Text string `json:"text,omitempty"`
}
```

#### 2. 传输层接口

```go
// internal/mcp/transport.go

type Transport interface {
    Connect(ctx context.Context) error
    Disconnect() error
    Send(ctx context.Context, req JSONRPCRequest) (*JSONRPCResponse, error)
    Notify(method string, params any) error
}
```

#### 3. MCP 客户端

```go
// internal/mcp/client.go

type Client struct {
    transport Transport
    tools     []Tool
}

func (c *Client) Initialize(ctx context.Context) (*InitializeResult, error) {
    // 发送 initialize 请求
}

func (c *Client) ListTools(ctx context.Context) ([]Tool, error) {
    // 获取工具列表
}

func (c *Client) CallTool(ctx context.Context, name string, args json.RawMessage) (*CallToolResult, error) {
    // 调用工具
}
```

#### 4. Tool 适配器

```go
// internal/mcp/tool_adapter.go

type MCPToolAdapter struct {
    client   *Client
    toolName string
    toolDesc string
    schema   json.RawMessage
}

func (t *MCPToolAdapter) Name() string  { return t.toolName }
func (t *MCPToolAdapter) Desc() string  { return t.toolDesc }
func (t *MCPToolAdapter) Args() map[string]any { 
    // 将 MCP schema 转换为 map[string]any
}

func (t *MCPToolAdapter) Run(ctx context.Context, args json.RawMessage) (string, error) {
    result, err := t.client.CallTool(ctx, t.toolName, args)
    if err != nil {
        return "", err
    }
    if result.IsError {
        return "", fmt.Errorf(result.Content[0].Text)
    }
    // 合并所有 content item
    var output strings.Builder
    for _, item := range result.Content {
        if item.Type == "text" {
            output.WriteString(item.Text)
        }
    }
    return output.String(), nil
}
```

#### 5. 配置扩展

```go
// internal/config/config.go

type MCPServerConfig struct {
    Name      string            `toml:"name"`
    Transport string            `toml:"transport"` // "stdio" | "sse"
    // stdio 配置
    Command   string            `toml:"command,omitempty"`
    Args      []string          `toml:"args,omitempty"`
    Env       map[string]string `toml:"env,omitempty"`
    // sse 配置
    URL       string            `toml:"url,omitempty"`
    Headers   map[string]string `toml:"headers,omitempty"`
}

type Config struct {
    // ... existing fields ...
    MCPServers []MCPServerConfig `toml:"mcp_servers,omitempty"`
}
```

#### 6. Tool.Set 集成

```go
// internal/tool/tool.go

func NewSetWithMCP(mcpTools []mcp.Tool) *Set {
    s := NewSet() // 内置工具
    // 添加 MCP 工具适配器
    for _, t := range mcpTools {
        s.Add(mcp.NewToolAdapter(t))
    }
    return s
}
```

### 生命周期管理

```
启动流程:
1. 读取配置中的 MCP 服务器列表
2. 为每个服务器创建 Transport
3. 启动 Transport 连接
4. 发送 initialize 握手
5. 调用 tools/list 获取工具列表
6. 将工具注册到 Tool.Set

运行期:
- 正常处理工具调用
- 监控服务器健康状态
- 自动重连（如果配置允许）

关闭流程:
1. 发送关闭通知
2. 断开 Transport 连接
3. 清理进程资源（stdio 模式）
```

### 错误处理策略

| 场景 | 处理方式 |
|-----|---------|
| 服务器启动失败 | 记录错误，继续启动其他服务器 |
| 调用超时 | 返回 timeout error 给 LLM |
| 服务器崩溃 | 标记为 unhealthy，可选择重连 |
| Schema 不兼容 | 跳过该工具，记录警告 |
| 工具调用失败 | 返回错误信息给 LLM |

## 接口设计

### 命令行参数

无新增参数，通过配置文件管理 MCP 服务器。

### TUI 命令

| 命令 | 描述 |
|-----|------|
| `/mcp` | 显示 MCP 服务器状态 |
| `/mcp reload` | 重新加载 MCP 配置 |
| `/mcp tools` | 列出所有 MCP 提供的工具 |

### 配置项

```toml
[mcp]
enabled = true                    # 全局开关
auto_reload = true               # 配置变更自动重载
health_check_interval = "30s"    # 健康检查间隔

[[mcp.servers]]
name = "filesystem"
transport = "stdio"
command = "npx"
args = ["-y", "@modelcontextprotocol/server-filesystem", "/home/user/projects"]
env = { NODE_ENV = "production" }
enabled = true

[[mcp.servers]]
name = "browser"
transport = "stdio"
command = "npx"
args = ["-y", "@anthropic-ai/mcp-server-browser"]

[[mcp.servers]]
name = "github"
transport = "sse"
url = "https://api.github.com/mcp/sse"
headers = { Authorization = "Bearer ${GITHUB_TOKEN}" }
timeout = "30s"                  # 单次调用超时
```

### 环境变量支持

配置中支持环境变量替换：`${VAR}` 或 `${VAR:-default}`

## 验收标准

### P0 (必须实现)

- [ ] 支持 stdio 传输方式的 MCP 服务器
- [ ] 实现 MCP 协议核心方法：initialize, tools/list, tools/call
- [ ] 将 MCP 工具无缝集成到现有 Tool.Set
- [ ] 配置文件支持 MCP 服务器定义
- [ ] 服务器启动失败不影响 otter 主程序
- [ ] 工具调用超时处理
- [ ] 支持 npx 启动的 MCP 服务器（最常见场景）

### P1 (强烈建议)

- [ ] 支持 SSE 传输方式
- [ ] TUI 命令 `/mcp` 查看状态
- [ ] 健康检查和自动重连
- [ ] 工具调用结果支持图片内容（转为 text 描述）
- [ ] 环境变量在配置中的替换支持

### P2 (可选)

- [ ] 支持 prompts/list 和 prompts/get（MCP Prompts）
- [ ] 支持 resources/list 和 resources/read（MCP Resources）
- [ ] MCP 服务器热重载（无需重启 otter）
- [ ] 工具调用性能指标统计

## 测试策略

### 单元测试

- MCP 协议消息序列化/反序列化
- Tool 适配器转换逻辑
- 配置解析

### 集成测试

- 使用官方 `@modelcontextprotocol/server-filesystem` 测试
- 模拟 MCP 服务器测试错误处理

### 手动测试

1. 配置 filesystem MCP 服务器
2. 验证工具列表正确加载
3. 验证工具调用正常工作
4. 验证错误场景处理

## 参考

### MCP 官方资源

- [MCP Specification](https://spec.modelcontextprotocol.io/)
- [MCP GitHub](https://github.com/modelcontextprotocol)
- [MCP TypeScript SDK](https://github.com/modelcontextprotocol/typescript-sdk)
- [MCP Python SDK](https://github.com/modelcontextprotocol/python-sdk)

### 官方 MCP 服务器

- [@modelcontextprotocol/server-filesystem](https://www.npmjs.com/package/@modelcontextprotocol/server-filesystem)
- [@modelcontextprotocol/server-postgres](https://www.npmjs.com/package/@modelcontextprotocol/server-postgres)
- [@anthropic-ai/mcp-server-browser](https://www.npmjs.com/package/@anthropic-ai/mcp-server-browser)
- [官方服务器列表](https://github.com/modelcontextprotocol/servers)

### 相关项目

- [Claude Code](https://claude.ai/code) - 已实现 MCP 支持
- [Cline](https://github.com/cline/cline) - VS Code 插件，支持 MCP
- [Continue](https://continue.dev/) - AI 编码助手，支持 MCP

## 风险评估

| 风险 | 可能性 | 影响 | 缓解措施 |
|-----|-------|-----|---------|
| MCP 协议变更 | 中 | 高 | 关注官方 spec 更新，设计可扩展的协议层 |
| 服务器进程泄漏 | 中 | 中 | 确保进程清理逻辑完善，添加超时监控 |
| 性能问题 | 低 | 中 | 添加调用超时，支持并发控制 |
| 安全问题 | 低 | 高 | 仅通过配置启用，不信任用户输入作为命令 |

## 后续优化方向

1. **Prompt 支持**: MCP 的 Prompts 功能可以让服务器提供预定义提示模板
2. **Resource 支持**: 让 Agent 可以读取 MCP 提供的资源上下文
3. **采样支持**: 支持 MCP 的 sampling 功能，让服务器请求 LLM 生成
4. **可视化**: TUI 中显示 MCP 服务器状态、工具调用详情
5. **市场集成**: 提供常用 MCP 服务器的一键配置

---

*Created: 2026-02-13*
*Author: otter-dev*
