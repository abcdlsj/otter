# Feature: Database Interaction Tool

## 背景与动机

### 当前问题

开发者在日常工作中频繁需要与数据库交互，包括查询数据、检查表结构、分析性能、执行迁移等。虽然 Otter 已有 `shell` 工具可以执行命令（如 `psql`, `mysql`），但存在以下痛点：

1. **安全性风险**：直接执行 SQL 命令容易导致误操作（如 `DROP TABLE`、`DELETE FROM` 等）
2. **无连接管理**：每次查询都需要提供完整的连接字符串，重复繁琐
3. **输出不友好**：原始数据库输出格式不统一，难以快速理解结果
4. **无元数据支持**：缺少表结构、索引、约束等元数据查询功能
5. **多数据库适配**：不同数据库（PostgreSQL, MySQL, SQLite, Redis 等）的 CLI 工具差异大
6. **缺少智能功能**：无法提供 SQL 优化建议、查询分析、数据可视化等

### 实际场景

```
场景1: 探索数据库结构
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
用户: 我刚接手一个项目，想了解 users 表的结构
现状: psql -d mydb -c "\d users"
问题: 需要记数据库连接信息，输出格式混乱

场景2: 执行查询
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
用户: 查询最近7天的订单数据
现状: 写 SQL，手动计算日期，执行查询
问题: SQL 语法错误排查耗时，结果格式化麻烦

场景3: 性能分析
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
用户: 这个查询很慢，帮我分析一下
现状: 手动执行 EXPLAIN，阅读执行计划
问题: 执行计划复杂，需要数据库专家知识

场景4: 多数据库环境
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
用户: 项目用 PostgreSQL 开发，用 MySQL 测试
现状: 需要记住两套命令（psql vs mysql）
问题: 命令差异导致混淆
```

### 用户价值

- **提升效率**：统一接口，自动识别数据库类型
- **降低风险**：只读模式、确认机制、危险操作检测
- **智能辅助**：表结构浏览、SQL 优化建议、查询模板
- **可视化输出**：格式化查询结果，支持导出

### 与现有工具的关系

`database` 工具不会替代 `shell` 工具，而是提供：
- 结构化的数据库接口
- 安全的默认配置（只读模式）
- 智能的元数据查询
- 友好的输出格式
- 连接池管理

`shell` 工具仍可用于：
- 数据库安装、配置
- 管理命令（如备份、恢复）
- 复杂的批量操作

## 功能描述

### 核心功能

#### 1. 连接管理
- 支持多种数据库类型：PostgreSQL, MySQL, SQLite, Redis
- 自动检测数据库类型（从连接字符串或配置）
- 连接池管理，复用连接
- 安全的凭据存储（环境变量或配置文件）

#### 2. 查询执行
- 执行 SELECT 查询（安全，默认启用）
- 执行 INSERT/UPDATE/DELETE（需显式启用写模式）
- 支持 EXPLAIN/ANALYZE 分析查询性能
- 支持参数化查询（防止 SQL 注入）

#### 3. 元数据查询
- 列出所有表/集合
- 查看表结构（列、类型、约束）
- 查看索引信息
- 查看外键关系
- 统计表行数、大小

#### 4. 智能功能
- SQL 语法验证（执行前检查）
- 危险操作检测（DROP, TRUNCATE 等）
- 查询结果格式化（表格、JSON）
- 数据导出（CSV, JSON）
- 查询历史记录

#### 5. Redis 专用功能
- Key 模式搜索
- Key 类型查看
- Value 类型转换
- TTL 管理

### 支持的数据库（MVP）

| 数据库 | 驱动 | 优先级 | 说明 |
|--------|------|--------|------|
| PostgreSQL | github.com/lib/pq | P0 | 最常用，功能完整 |
| MySQL | go-sql-driver/mysql | P0 | 广泛使用 |
| SQLite | mattn/go-sqlite3 | P1 | 轻量级，本地开发 |
| Redis | go-redis/redis/v9 | P1 | 缓存、消息队列 |

未来可扩展：MongoDB, ClickHouse, ElasticSearch 等

## 技术方案

### 架构设计

```
┌─────────────────────────────────────────────────────────────┐
│                         otter                               │
│  ┌─────────────┐    ┌─────────────┐    ┌─────────────┐     │
│  │   Agent     │───▶│  Tool.Set   │───▶│   Builtin   │     │
│  │             │    │             │    │   Tools     │     │
│  └─────────────┘    └─────────────┘    └─────────────┘     │
│                                            │                 │
│                                            ▼                 │
│                              ┌─────────────────────────┐     │
│                              │      Database Tool       │     │
│                              │  ┌───────────────────┐   │     │
│                              │  │  Connection Pool  │   │     │
│                              │  └───────────────────┘   │     │
│                              │  ┌───────────────────┐   │     │
│                              │  │    Query Engine   │   │     │
│                              │  └───────────────────┘   │     │
│                              │  ┌───────────────────┐   │     │
│                              │  │  Metadata Query   │   │     │
│                              │  └───────────────────┘   │     │
│                              │  ┌───────────────────┐   │     │
│                              │  │   Formatter       │   │     │
│                              │  └───────────────────┘   │     │
│                              └─────────────────────────┘     │
│                                    │   │   │                  │
│                                    ▼   ▼   ▼                  │
│                         ┌────────────┐ ┌────────┐            │
│                         │ PostgreSQL │ │ MySQL  │            │
│                         │  Driver    │ │ Driver │            │
│                         └────────────┘ └────────┘            │
└─────────────────────────────────────────────────────────────┘
```

### 文件结构

```
internal/
├── database/                    # 新增包
│   ├── database.go              # 核心接口和实现
│   ├── connection.go            # 连接管理
│   ├── driver.go                # 数据库驱动注册
│   ├── query.go                 # 查询执行
│   ├── metadata.go              # 元数据查询
│   ├── formatter.go             # 结果格式化
│   ├── safety.go                # 安全检查
│   ├── postgresql/             # PostgreSQL 专用
│   │   └── postgresql.go
│   ├── mysql/                   # MySQL 专用
│   │   └── mysql.go
│   ├── sqlite/                  # SQLite 专用
│   │   └── sqlite.go
│   └── redis/                   # Redis 专用
│       └── redis.go
└── tool/
    └── database.go              # Database 工具（调用 database 包）
```

### 核心实现

#### 1. 数据库接口定义

```go
// internal/database/database.go

type Database interface {
    // 连接管理
    Connect(ctx context.Context, dsn string) error
    Close() error
    Ping(ctx context.Context) error
    Type() string

    // 查询执行
    Query(ctx context.Context, sql string, args ...any) (Result, error)
    QueryRow(ctx context.Context, sql string, args ...any) (map[string]any, error)
    Exec(ctx context.Context, sql string, args ...any) (Result, error)
    Explain(ctx context.Context, sql string, args ...any) (string, error)

    // 元数据查询
    ListTables(ctx context.Context) ([]TableInfo, error)
    DescribeTable(ctx context.Context, name string) (TableSchema, error)
    ListIndexes(ctx context.Context, table string) ([]IndexInfo, error)

    // 统计信息
    TableStats(ctx context.Context, table string) (TableStats, error)
}

type Result struct {
    Columns []string
    Rows    []map[string]any
    Affected int64
    Duration time.Duration
}

type TableInfo struct {
    Name   string
    Type   string // "table", "view", "sequence", etc.
}

type TableSchema struct {
    Name    string
    Columns []ColumnInfo
    Constraints []ConstraintInfo
}

type ColumnInfo struct {
    Name     string
    Type     string
    Nullable bool
    Default  *string
    Comment  *string
}

type ConstraintInfo struct {
    Name       string
    Type       string // "PRIMARY KEY", "FOREIGN KEY", etc.
    Columns    []string
    References *ForeignKeyInfo
}
```

#### 2. 连接池管理

```go
// internal/database/connection.go

type Pool struct {
    mu    sync.RWMutex
    conns map[string]*connEntry // key: dsn hash
}

type connEntry struct {
    db      Database
    lastUse time.Time
    refCount int
}

func (p *Pool) Get(ctx context.Context, dsn string) (Database, error) {
    // 1. 检查现有连接
    // 2. 如果不存在，创建新连接
    // 3. 自动检测数据库类型
    // 4. 返回连接
}

func (p *Pool) Release(dsn string) {
    // 减少引用计数，定期清理空闲连接
}

func DetectDatabaseType(dsn string) string {
    // postgresql://... -> "postgresql"
    // mysql://... -> "mysql"
    // redis://... -> "redis"
    // /path/to/file.db -> "sqlite"
}
```

#### 3. PostgreSQL 实现

```go
// internal/database/postgresql/postgresql.go

type PostgreSQL struct {
    db *sql.DB
}

func (p *PostgreSQL) Connect(ctx context.Context, dsn string) error {
    db, err := sql.Open("postgres", dsn)
    if err != nil {
        return err
    }
    p.db = db
    return db.PingContext(ctx)
}

func (p *PostgreSQL) ListTables(ctx context.Context) ([]TableInfo, error) {
    query := `
        SELECT table_name, table_type
        FROM information_schema.tables
        WHERE table_schema = 'public'
        ORDER BY table_name
    `
    rows, err := p.db.QueryContext(ctx, query)
    // ... 处理结果
}

func (p *PostgreSQL) DescribeTable(ctx context.Context, name string) (TableSchema, error) {
    // 查询 column, constraint 信息
    // ... 处理结果
}

func (p *PostgreSQL) Explain(ctx context.Context, sql string, args ...any) (string, error) {
    explainSQL := "EXPLAIN (ANALYZE, BUFFERS) " + sql
    result, err := p.Query(ctx, explainSQL, args...)
    // 格式化执行计划
}
```

#### 4. MySQL 实现

```go
// internal/database/mysql/mysql.go

type MySQL struct {
    db *sql.DB
}

// 类似 PostgreSQL 实现
// 使用 information_schema 查询元数据
```

#### 5. Redis 实现

```go
// internal/database/redis/redis.go

type Redis struct {
    client *redis.Client
}

func (r *Redis) Connect(ctx context.Context, dsn string) error {
    // 解析 redis://... URL
    // 创建 redis.Client
}

func (r *Redis) Query(ctx context.Context, pattern string, _ ...any) (Result, error) {
    // 支持模式查询，如 "user:*" -> 列出所有匹配的 key
    keys, err := r.client.Keys(ctx, pattern).Result()
    // 返回 key 列表及其类型、TTL 等信息
}

func (r *Redis) GetValue(ctx context.Context, key string) (map[string]any, error) {
    // 检测 key 类型
    // 根据类型调用 GET/HGETALL/LRANGE 等
    // 返回结构化数据
}
```

#### 6. Database Tool 实现

```go
// internal/tool/database.go

type Database struct {
    pool *database.Pool
}

func (Database) Name() string { return "database" }
func (Database) Desc() string {
    return "Interact with databases (query, schema, stats). Supports PostgreSQL, MySQL, SQLite, Redis."
}

func (Database) Args() map[string]any {
    return map[string]any{
        "type": "object",
        "properties": map[string]any{
            "action": map[string]any{
                "type": "string",
                "enum": []string{"query", "tables", "describe", "indexes", "stats", "explain"},
                "description": "Action to perform",
            },
            "dsn": map[string]any{
                "type": "string",
                "description": "Database connection string (or environment variable name with $ prefix)",
            },
            "sql": map[string]any{
                "type": "string",
                "description": "SQL query to execute (for 'query' action)",
            },
            "table": map[string]any{
                "type": "string",
                "description": "Table name (for 'describe', 'indexes', 'stats' actions)",
            },
            "readonly": map[string]any{
                "type": "boolean",
                "description": "Enable read-only mode (reject INSERT/UPDATE/DELETE)",
            },
            "format": map[string]any{
                "type": "string",
                "enum": []string{"table", "json", "csv"},
                "description": "Output format (default: table)",
            },
        },
    }
}

func (d *Database) Run(ctx context.Context, raw json.RawMessage) (string, error) {
    var args struct {
        Action   string `json:"action"`
        DSN      string `json:"dsn"`
        SQL      string `json:"sql"`
        Table    string `json:"table"`
        Readonly bool   `json:"readonly"`
        Format   string `json:"format"`
    }
    if err := json.Unmarshal(raw, &args); err != nil {
        return "", err
    }

    // 解析 DSN（支持环境变量）
    dsn := d.resolveDSN(args.DSN)

    // 获取数据库连接
    db, err := d.pool.Get(ctx, dsn)
    if err != nil {
        return "", err
    }

    // 执行对应操作
    switch args.Action {
    case "query":
        return d.executeQuery(ctx, db, args.SQL, args.Readonly, args.Format)
    case "tables":
        return d.listTables(ctx, db)
    case "describe":
        return d.describeTable(ctx, db, args.Table)
    case "indexes":
        return d.listIndexes(ctx, db, args.Table)
    case "stats":
        return d.tableStats(ctx, db, args.Table)
    case "explain":
        return d.explainQuery(ctx, db, args.SQL)
    default:
        return "", fmt.Errorf("unknown action: %s", args.Action)
    }
}
```

#### 7. 结果格式化

```go
// internal/database/formatter.go

type Formatter struct{}

func (f *Formatter) Table(result database.Result) string {
    // 表格格式化
    // 列对齐、边框绘制
}

func (f *Formatter) JSON(result database.Result) string {
    // JSON 格式化
}

func (f *Formatter) CSV(result database.Result) string {
    // CSV 格式化
}
```

#### 8. 安全检查

```go
// internal/database/safety.go

type SafetyChecker struct{}

func (s *SafetyChecker) IsDangerous(sql string) bool {
    // 检测危险操作：DROP, TRUNCATE, DELETE without WHERE, etc.
    upper := strings.ToUpper(sql)
    dangerous := []string{"DROP", "TRUNCATE"}
    for _, d := range dangerous {
        if strings.Contains(upper, d) {
            return true
        }
    }
    // 检测 DELETE without WHERE
    if strings.Contains(upper, "DELETE") && !strings.Contains(upper, "WHERE") {
        return true
    }
    return false
}

func (s *SafetyChecker) ValidateSQL(sql string) error {
    // 基本语法检查
    // 防止明显的 SQL 注入
}
```

### 配置管理

```go
// internal/config/config.go

type DatabaseConfig struct {
    DefaultDSN string `toml:"default_dsn,omitempty"` // 默认连接字符串
    Readonly   bool   `toml:"readonly"`               // 全局只读模式
    MaxConns   int    `toml:"max_conns"`              // 最大连接数
    Timeout    int    `toml:"timeout"`                // 查询超时（秒）
}

type Config struct {
    // ... existing fields ...
    Database DatabaseConfig `toml:"database,omitempty"`
}
```

### 连接字符串支持

支持多种格式：

1. **完整 DSN**
   ```
   postgresql://user:pass@localhost:5432/mydb
   mysql://user:pass@localhost:3306/mydb
   redis://localhost:6379/0
   ```

2. **环境变量引用**
   ```
   $DATABASE_URL
   $POSTGRES_DSN
   ```

3. **SQLite 文件路径**
   ```
   /path/to/database.db
   ./data/app.db
   ```

## 接口设计

### 命令行参数

```go
// 详见上面的 Args() 定义
```

### 使用示例

#### 示例 1：列出所有表
```json
{
  "action": "tables",
  "dsn": "postgresql://user:pass@localhost/mydb"
}
```

输出：
```
Tables in mydb:
┌──────────────────┬────────┐
│ Name             │ Type   │
├──────────────────┼────────┤
│ users            │ table  │
│ orders           │ table  │
│ products         │ table  │
│ order_items      │ table  │
│ user_sessions_v1 │ view   │
└──────────────────┴────────┘
```

#### 示例 2：查看表结构
```json
{
  "action": "describe",
  "dsn": "$DATABASE_URL",
  "table": "users"
}
```

输出：
```
Table: users
┌─────────────┬─────────┬──────────┬─────────┬────────────┐
│ Column      │ Type    │ Nullable │ Default │ Comment    │
├─────────────┼─────────┼──────────┼─────────┼────────────┤
│ id          │ bigint  │ NO       │         │ PK         │
│ email       │ varchar │ NO       │         │ unique     │
│ name        │ varchar │ YES      │ NULL    │            │
│ created_at  │ timestam│ YES      │ now()   │            │
│ updated_at  │ timestam│ YES      │ now()   │            │
└─────────────┴─────────┴──────────┴─────────┴────────────┘

Foreign Keys:
  - orders.user_id → users.id
```

#### 示例 3：执行查询
```json
{
  "action": "query",
  "dsn": "$DATABASE_URL",
  "sql": "SELECT id, email, name FROM users WHERE created_at > NOW() - INTERVAL '7 days' LIMIT 10",
  "readonly": true
}
```

输出：
```
Query executed in 12ms
┌────┬────────────────────┬──────────────┐
│ id │ email              │ name         │
├────┼────────────────────┼──────────────┤
│ 42 │ alice@example.com  │ Alice Wang   │
│ 43 │ bob@example.com    │ Bob Chen     │
│ 44 │ carol@example.com  │ Carol Li     │
└────┴────────────────────┴──────────────┘
3 rows returned
```

#### 示例 4：查询统计
```json
{
  "action": "stats",
  "dsn": "$DATABASE_URL",
  "table": "orders"
}
```

输出：
```
Table: orders statistics
┌─────────────────┬─────────────┐
│ Metric          │ Value       │
├─────────────────┼─────────────┤
│ Total Rows      │ 1,234,567   │
│ Table Size      │ 245.6 MB    │
│ Indexes         │ 3           │
│ Index Size      │ 78.2 MB     │
│ Last Analyzed   │ 2 hours ago │
└─────────────────┴─────────────┘
```

#### 示例 5：查询分析
```json
{
  "action": "explain",
  "dsn": "$DATABASE_URL",
  "sql": "SELECT * FROM orders WHERE user_id = 42 ORDER BY created_at DESC LIMIT 20"
}
```

输出：
```
QUERY PLAN
────────────────────────────────────────────────────────────
Limit  (cost=0.43..16.53 rows=20 width=120)
  →  Index Scan Backward using orders_user_id_created_at_idx
      on orders  (cost=0.43..12345.67 rows=15000 width=120)
      Index Cond: (user_id = 42)

✓ Uses index efficiently
⚠ Large row estimate (15,000) - consider adding date filter
```

#### 示例 6：Redis 查询
```json
{
  "action": "query",
  "dsn": "redis://localhost:6379/0",
  "sql": "user:*"
}
```

输出：
```
Keys matching "user:*" (3 found)
┌────────────────┬────────┬─────────┬────────┐
│ Key            │ Type   │ Size    │ TTL    │
├────────────────┼────────┼─────────┼────────┤
│ user:42:profile │ hash   │ 256 B   │ -1     │
│ user:42:sessions│ list   │ 1.2 KB  │ 3600   │
│ user:42:cache   │ string │ 128 B   │ 300    │
└────────────────┴────────┴─────────┴────────┘

Use 'action=query' with 'sql=<key>' to view content
```

### 配置示例

```toml
# ~/.config/otter/config.toml

[database]
default_dsn = "$DATABASE_URL"  # 默认连接字符串
readonly = true                # 默认只读模式（安全）
max_conns = 5                  # 最大连接数
timeout = 30                   # 查询超时（秒）

# 环境变量（不在配置文件中保存密码）
# export DATABASE_URL="postgresql://user:pass@localhost/mydb"
```

## 验收标准

### 功能验收

#### P0（必须实现）

- [ ] **PostgreSQL 支持**
  - [ ] 连接和 Ping 测试
  - [ ] 执行 SELECT 查询
  - [ ] 列出所有表
  - [ ] 查看表结构（列、类型、约束）
  - [ ] 查询结果表格格式化
  - [ ] 支持环境变量引用（$DATABASE_URL）

- [ ] **安全特性**
  - [ ] 只读模式默认启用
  - [ ] 危险操作检测（DROP, TRUNCATE, DELETE without WHERE）
  - [ ] 连接字符串验证
  - [ ] 查询超时控制

- [ ] **基础功能**
  - [ ] 连接池管理
  - [ ] 自动检测数据库类型
  - [ ] 错误处理和友好提示
  - [ ] JSON 格式输出选项

#### P1（强烈建议）

- [ ] **MySQL 支持**
  - [ ] 完整功能对齐 PostgreSQL
  - [ ] MySQL 专用元数据查询

- [ ] **增强功能**
  - [ ] 查询历史记录
  - [ ] EXPLAIN 分析和可视化
  - [ ] CSV 导出
  - [ ] 表统计信息
  - [ ] 索引列表

- [ ] **性能优化**
  - [ ] 连接复用
  - [ ] 空闲连接清理
  - [ ] 结果集分页（大结果集）

#### P2（可选）

- [ ] **SQLite 支持**
- [ ] **Redis 支持**
- [ ] 事务支持（BEGIN/COMMIT/ROLLBACK）
- [ ] 批量操作（批量 INSERT）
- [ ] 查询模板功能
- [ ] SQL 自动补全建议
- [ ] 数据库迁移支持

### 代码质量验收

- [ ] 遵循 CLAUDE.md 代码风格
  - [ ] 简洁的命名
  - [ ] 小函数（一屏可读）
  - [ ] 错误立即处理
  - [ ] 接口设计清晰

- [ ] 性能要求
  - [ ] 连接建立时间 < 1s
  - [ ] 查询执行无额外显著开销
  - [ ] 连接池高效复用

- [ ] 安全性
  - [ ] 不在日志中泄露密码
  - [ ] 只读模式严格生效
  - [ ] 危险操作检测准确

- [ ] 测试覆盖
  - [ ] 单元测试：连接管理、查询构建、格式化
  - [ ] 集成测试：使用 testcontainers 运行实际数据库
  - [ ] 安全测试：SQL 注入防护

### 文档验收

- [ ] 工具描述清晰准确
- [ ] 参数文档完整
- [ ] 使用示例丰富（涵盖所有数据库类型）
- [ ] 安全注意事项明确

## 测试策略

### 单元测试

- 连接池管理逻辑
- 数据库类型检测
- SQL 解析和安全检查
- 结果格式化逻辑

### 集成测试

使用 testcontainers 运行真实数据库：

```go
func TestPostgreSQL(t *testing.T) {
    ctx := context.Background()
    container := testcontainers.GenericContainer(ctx, testcontainers.GenericContainerRequest{
        ContainerRequest: testcontainers.ContainerRequest{
            Image:        "postgres:15",
            ExposedPorts: []string{"5432/tcp"},
            Env: map[string]string{
                "POSTGRES_PASSWORD": "test",
            },
        },
        Started: true,
    })
    // ... 运行测试
}
```

### 手动测试场景

1. **PostgreSQL 完整流程**
   - 连接、列出表、查询、分析
   - 只读模式验证
   - 危险操作检测

2. **MySQL 完整流程**
   - 同 PostgreSQL

3. **Redis 基础操作**
   - 连接、key 列表、value 查看

4. **错误场景**
   - 错误的 DSN
   - SQL 语法错误
   - 超时处理

## 参考

### Go 数据库驱动

- **PostgreSQL**: [github.com/lib/pq](https://github.com/lib/pq)
- **MySQL**: [github.com/go-sql-driver/mysql](https://github.com/go-sql-driver/mysql)
- **SQLite**: [github.com/mattn/go-sqlite3](https://github.com/mattn/go-sqlite3)
- **Redis**: [github.com/go-redis/redis/v9](https://github.com/go-redis/redis)

### 数据库文档

- **PostgreSQL**: https://www.postgresql.org/docs/
- **MySQL**: https://dev.mysql.com/doc/
- **SQLite**: https://www.sqlite.org/docs.html
- **Redis**: https://redis.io/docs/

### 相关项目

- **gosexy/db**: 通用数据库接口抽象
- **sqlx**: Go database 库扩展
- **GORM**: Go ORM（参考元数据查询实现）
- **pgx**: PostgreSQL 驱动（性能优化参考）

### 安全最佳实践

- OWASP SQL Injection Prevention: https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html
- PostgreSQL Security Best Practices: https://wiki.postgresql.org/wiki/Don%27t_Do_This

## 风险评估

| 风险 | 可能性 | 影响 | 缓解措施 |
|-----|-------|-----|---------|
| 数据库连接泄漏 | 中 | 中 | 完善连接池清理逻辑，添加超时监控 |
| SQL 注入漏洞 | 低 | 高 | 严格的输入验证，参数化查询 |
| 性能开销 | 低 | 中 | 连接复用，避免重复建立连接 |
| 误操作导致数据丢失 | 低 | 高 | 默认只读模式，危险操作检测，确认机制 |
| 多数据库兼容性问题 | 中 | 中 | 充分的测试覆盖，渐进式实现 |

## 后续优化方向

1. **高级查询分析**: 查询优化建议、索引推荐
2. **数据可视化**: 生成图表、趋势分析
3. **查询模板**: 常用查询模板库
4. **事务支持**: BEGIN/COMMIT/ROLLBACK
5. **流式结果**: 大数据集流式返回
6. **监控指标**: 数据库性能指标采集
7. **备份恢复**: 集成数据库备份功能
8. **ORM 集成**: 与 GORM 等ORM库集成

---

**PRD 版本**: 1.0
**创建日期**: 2026-02-14
**预计工期**: 4-5 天
**优先级**: 高（提升开发效率，增强实用性）
