# Feature: Agent Tool Call Approval System (智能工具调用审批系统)

## 背景与动机

### 现状问题

当前 Otter 的 Agent 在执行工具调用时完全自主，一旦决定使用某个工具，就会立即执行。这在某些场景下存在问题：

1. **安全风险**: Agent 可能执行潜在危险的操作（如 `rm -rf`、`git reset --hard`）而无需用户确认
2. **不可控感**: 用户无法预知 Agent 将要执行什么操作，缺乏透明度
3. **误操作风险**: Agent 可能误解用户意图，执行错误的文件修改
4. **配置未生效**: 现有的 `SecurityConfig.ConfirmDestructive` 配置项尚未实现具体功能

### 实际场景

```
场景1: 危险的 shell 命令
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
用户: 帮我清理一下临时文件
Agent: [执行] shell("rm -rf /tmp/*")
结果: 不小心删除了重要文件

场景2: 意外的文件修改
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
用户: 帮我优化这段代码
Agent: [执行] edit(修改了错误的文件)
结果: 破坏了工作代码

场景3: 需要确认的长耗时操作
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
用户: 运行测试
Agent: [执行] shell("go test -race ./...")  // 可能需要5分钟
用户: 等等，我想先检查一下...
```

### 为什么需要这个功能

1. **安全性**: 为破坏性操作增加确认机制，防止误操作
2. **透明度**: 让用户清楚知道 Agent 将要做什么
3. **可控性**: 用户可以选择批准、拒绝或修改工具调用
4. **信任**: 建立用户对 Agent 的信任，放心让 Agent 自主工作

### 竞品对比

| 工具 | 工具审批 | 说明 |
|------|----------|------|
| Claude Code | ✅ | 支持对 shell 命令的确认模式 (`--dangerously-skip-permissions`) |
| Cursor | ⚠️ 有限 | 编辑器内操作需要确认，但 Agent 模式较自主 |
| GitHub Copilot | ❌ | 纯代码补全，无工具调用 |
| Aider | ✅ | 支持在 commit 前确认修改 |
| Otter | ❌ | **待实现** |

---

## 功能描述

### 核心功能

1. **智能审批级别**: 根据工具类型和操作风险自动分级
2. **可配置策略**: 用户可自定义哪些操作需要确认
3. **批量审批**: 对于安全的操作可以自动批准，提高效率
4. **审批历史**: 记住用户的选择，减少重复确认

### 审批级别设计

```yaml
approval_levels:
  auto:      # 自动执行，无需确认
    - view      # 查看文件
    - list      # 列出目录
    - glob      # 文件匹配
    - grep      # 搜索文本
    - websearch # 网络搜索
    - webfetch  # 获取网页
    - compact   # 压缩历史
    
  readonly:  # 只读操作，低风险
    - git status
    - git log
    - git diff
    
  suggest:   # 建议确认（显示但不阻塞）
    - shell (非破坏性命令)
    
  confirm:   # 必须确认
    - shell (破坏性命令: rm, mv, git reset, etc.)
    - edit    # 文件编辑
    - git (修改性操作: commit, push, checkout, etc.)
```

### 使用场景

```
场景1: 自动批准的只读操作
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
用户: 帮我看看 main.go 的内容
Agent: [view] main.go
      → 自动执行，无需确认

场景2: 破坏性操作需要确认
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
用户: 删除所有测试文件
Agent: [shell] "rm -rf *_test.go"
      ⚠️ 需要确认: 删除 15 个测试文件
      [A] 批准  [R] 拒绝  [E] 编辑  [?] 帮助
用户: A
Agent: 执行删除...

场景3: 文件编辑预览
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
用户: 给所有函数添加注释
Agent: [edit] utils.go
      ⚠️ 即将修改: utils.go
      ┌─ 预览 ──────────────────────┐
      │  - func helper() {          │
      │  + // helper 辅助函数       │
      │  + func helper() {          │
      └─────────────────────────────┘
      [A] 批准  [R] 拒绝  [S] 跳过此文件  [?] 帮助

场景4: 批量操作的快捷确认
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
用户: 重构所有错误处理
Agent: 将编辑 8 个文件，是否继续？
      [A] 批准全部  [Y] 逐个确认  [N] 取消
```

---

## 技术方案

### 架构设计

```
┌─────────────────────────────────────────────────────────────────┐
│                           TUI                                    │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────────────┐  │
│  │ 用户输入     │  │ 审批提示 UI  │  │ 审批历史展示        │  │
│  │              │  │ (bubbletea)  │  │                      │  │
│  └──────────────┘  └──────────────┘  └──────────────────────┘  │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                      Agent (Modified)                            │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────────────┐  │
│  │ ReAct Loop   │  │ Tool Selector│  │ Execution Engine    │  │
│  │              │  │              │  │                      │  │
│  └──────┬───────┘  └──────┬───────┘  └──────────┬───────────┘  │
│         │                 │                     │              │
│         └─────────────────┼─────────────────────┘              │
│                           │                                    │
│                           ▼                                    │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │  Approval Manager (NEW)                                   │  │
│  │  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐ │  │
│  │  │ 风险评估 │→ │ 决策引擎 │→ │ 用户交互 │→ │ 执行控制 │ │  │
│  │  │ assess() │  │ decide() │  │ prompt() │  │ exec()   │ │  │
│  │  └──────────┘  └──────────┘  └──────────┘  └──────────┘ │  │
│  └──────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                      Storage Layer                               │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │  ~/.config/otter/approval.json                             │  │
│  │  ├── trusted_patterns: ["git status", "go test ./..."]    │  │
│  │  ├── denied_patterns: ["rm -rf /", "sudo"]                │  │
│  │  └── history: [/* 最近的审批记录 */]                       │  │
│  └──────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────┘
```

### 文件改动清单

#### 1. `internal/approval/` (新增目录)

**`internal/approval/types.go`** - 核心类型定义
```go
package approval

import (
    "time"
    "github.com/abcdlsj/otter/internal/types"
)

// Level 定义审批级别
type Level int

const (
    LevelAuto     Level = iota // 自动执行
    LevelReadonly              // 只读，低风险
    LevelSuggest               // 建议确认
    LevelConfirm               // 必须确认
    LevelDeny                  // 自动拒绝
)

// Decision 审批决策
type Decision int

const (
    DecisionPending Decision = iota
    DecisionApprove
    DecisionReject
    DecisionEdit
    DecisionSkip
)

// Request 审批请求
type Request struct {
    ID        string
    ToolName  string
    Args      map[string]any
    RiskLevel Level
    Preview   string        // 操作预览
    Context   string        // 上下文信息
    Timestamp time.Time
}

// Response 审批响应
type Response struct {
    RequestID string
    Decision  Decision
    EditedArgs map[string]any // 用户修改后的参数
    Remember  bool           // 是否记住此选择
}

// Policy 审批策略
type Policy struct {
    DefaultLevel Level              `json:"default_level"`
    ToolLevels   map[string]Level   `json:"tool_levels"`
    ShellRules   []ShellRule        `json:"shell_rules"`
    TrustedCmds  []string           `json:"trusted_cmds"`
    DeniedCmds   []string           `json:"denied_cmds"`
}

// ShellRule shell 命令审批规则
type ShellRule struct {
    Pattern string `json:"pattern"`
    Level   Level  `json:"level"`
    Reason  string `json:"reason,omitempty"`
}
```

**`internal/approval/manager.go`** - 审批管理器
```go
package approval

import (
    "context"
    "regexp"
    "strings"
)

// Manager 管理工具调用的审批流程
type Manager struct {
    policy   *Policy
    store    *Store
    ui       UI
}

// UI 审批交互接口
type UI interface {
    // Prompt 显示审批提示并获取用户决策
    Prompt(ctx context.Context, req *Request) (*Response, error)
    
    // PreviewEdit 显示编辑预览
    PreviewEdit(filepath string, oldContent, newContent string) error
    
    // PreviewShell 显示 shell 命令预览
    PreviewShell(cmd string, dryRunOutput string) error
}

func NewManager(policy *Policy, store *Store, ui UI) *Manager

// Assess 评估工具调用的风险级别
func (m *Manager) Assess(toolName string, args map[string]any) Level {
    // 1. 检查工具级别
    if level, ok := m.policy.ToolLevels[toolName]; ok {
        return level
    }
    
    // 2. shell 命令特殊处理
    if toolName == "shell" {
        return m.assessShell(args["cmd"].(string))
    }
    
    // 3. edit 操作特殊处理
    if toolName == "edit" {
        return LevelConfirm
    }
    
    // 4. 默认级别
    return m.policy.DefaultLevel
}

// Request 发起审批请求
func (m *Manager) Request(ctx context.Context, toolName string, args map[string]any) (*Response, error) {
    level := m.Assess(toolName, args)
    
    // 自动级别直接通过
    if level == LevelAuto {
        return &Response{Decision: DecisionApprove}, nil
    }
    
    // 拒绝级别直接拒绝
    if level == LevelDeny {
        return &Response{Decision: DecisionReject}, nil
    }
    
    // 检查历史记忆
    if resp := m.checkHistory(toolName, args); resp != nil {
        return resp, nil
    }
    
    // 构建审批请求
    req := &Request{
        ID:        generateID(),
        ToolName:  toolName,
        Args:      args,
        RiskLevel: level,
        Timestamp: time.Now(),
    }
    
    // 生成预览
    req.Preview = m.generatePreview(toolName, args)
    
    // 显示审批 UI
    return m.ui.Prompt(ctx, req)
}

// assessShell 评估 shell 命令风险
func (m *Manager) assessShell(cmd string) Level {
    cmd = strings.TrimSpace(cmd)
    
    // 检查信任列表
    for _, trusted := range m.policy.TrustedCmds {
        if matches(cmd, trusted) {
            return LevelAuto
        }
    }
    
    // 检查拒绝列表
    for _, denied := range m.policy.DeniedCmds {
        if matches(cmd, denied) {
            return LevelDeny
        }
    }
    
    // 规则匹配
    for _, rule := range m.policy.ShellRules {
        if matched, _ := regexp.MatchString(rule.Pattern, cmd); matched {
            return rule.Level
        }
    }
    
    // 危险命令检测
    dangerous := []string{"rm -rf", "sudo", "mkfs", "dd if", "> /dev", ":(){"}
    for _, d := range dangerous {
        if strings.Contains(cmd, d) {
            return LevelConfirm
        }
    }
    
    // git 修改性操作
    gitModifying := []string{"git reset", "git checkout", "git clean", "git rebase"}
    for _, g := range gitModifying {
        if strings.HasPrefix(cmd, g) {
            return LevelConfirm
        }
    }
    
    // 默认只读级别
    return LevelReadonly
}

func (m *Manager) generatePreview(toolName string, args map[string]any) string
func (m *Manager) checkHistory(toolName string, args map[string]any) *Response
```

**`internal/approval/store.go`** - 审批历史存储
```go
package approval

import (
    "encoding/json"
    "os"
    "path/filepath"
)

// Store 持久化审批历史和策略
type Store struct {
    path string
}

type ApprovalRecord struct {
    ToolName  string    `json:"tool_name"`
    ArgsHash  string    `json:"args_hash"`
    Decision  Decision  `json:"decision"`
    Timestamp time.Time `json:"timestamp"`
}

func NewStore(configDir string) *Store

func (s *Store) LoadPolicy() (*Policy, error)
func (s *Store) SavePolicy(p *Policy) error
func (s *Store) AddRecord(r *ApprovalRecord) error
func (s *Store) GetHistory(toolName string) []ApprovalRecord
func (s *Store) ClearHistory() error
```

**`internal/approval/ui.go`** - TUI 审批界面
```go
package approval

import (
    "context"
    "fmt"
    "strings"
    
    tea "github.com/charmbracelet/bubbletea"
    "github.com/charmbracelet/lipgloss"
)

// BubbleTeaUI 基于 bubbletea 的审批 UI
type BubbleTeaUI struct {
    program *tea.Program
}

func NewBubbleTeaUI() *BubbleTeaUI

func (u *BubbleTeaUI) Prompt(ctx context.Context, req *Request) (*Response, error) {
    model := approvalModel{
        request: req,
        choices: u.buildChoices(req),
        cursor:  0,
        done:    make(chan *Response, 1),
    }
    
    u.program = tea.NewProgram(model)
    
    go func() {
        if finalModel, err := u.program.Run(); err == nil {
            if m, ok := finalModel.(approvalModel); ok {
                m.done <- m.response
            }
        }
    }()
    
    select {
    case resp := <-model.done:
        return resp, nil
    case <-ctx.Done():
        return nil, ctx.Err()
    }
}

type approvalModel struct {
    request  *Request
    choices  []choice
    cursor   int
    response *Response
    done     chan *Response
    remember bool
}

type choice struct {
    key         string
    label       string
    description string
    decision    Decision
}

func (u *BubbleTeaUI) buildChoices(req *Request) []choice {
    base := []choice{
        {"a", "Approve", "执行此操作", DecisionApprove},
        {"r", "Reject", "拒绝此操作", DecisionReject},
    }
    
    if req.ToolName == "edit" {
        base = append(base, choice{"e", "Edit", "修改参数后执行", DecisionEdit})
    }
    
    if req.ToolName == "shell" {
        base = append(base, choice{"d", "Dry Run", "先试运行", DecisionSuggest})
    }
    
    return base
}

func (m approvalModel) Init() tea.Cmd { return nil }

func (m approvalModel) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
    switch msg := msg.(type) {
    case tea.KeyMsg:
        switch msg.String() {
        case "up", "k":
            if m.cursor > 0 {
                m.cursor--
            }
        case "down", "j":
            if m.cursor < len(m.choices)-1 {
                m.cursor++
            }
        case "enter":
            m.response = &Response{
                RequestID: m.request.ID,
                Decision:  m.choices[m.cursor].decision,
                Remember:  m.remember,
            }
            return m, tea.Quit
        case "a", "y":
            m.response = &Response{
                RequestID: m.request.ID,
                Decision:  DecisionApprove,
                Remember:  m.remember,
            }
            return m, tea.Quit
        case "r", "n":
            m.response = &Response{
                RequestID: m.request.ID,
                Decision:  DecisionReject,
            }
            return m, tea.Quit
        case "t":
            m.remember = !m.remember
        }
    }
    return m, nil
}

func (m approvalModel) View() string {
    var b strings.Builder
    
    // 标题和风险提示
    title := lipgloss.NewStyle().
        Bold(true).
        Foreground(lipgloss.Color("#FCAF3E")).
        Render("⚠️  Approval Required")
    b.WriteString(title + "\n\n")
    
    // 工具信息
    b.WriteString(fmt.Sprintf("Tool: %s\n", m.request.ToolName))
    if m.request.RiskLevel == LevelConfirm {
        b.WriteString(lipgloss.NewStyle().
            Foreground(lipgloss.Color("#EF2929")).
            Render("Risk Level: HIGH") + "\n")
    }
    b.WriteString("\n")
    
    // 预览
    if m.request.Preview != "" {
        b.WriteString("Preview:\n")
        b.WriteString(lipgloss.NewStyle().
            BorderStyle(lipgloss.RoundedBorder()).
            BorderForeground(lipgloss.Color("#555753")).
            Padding(0, 1).
            Render(m.request.Preview) + "\n\n")
    }
    
    // 选项
    b.WriteString("Choose:\n")
    for i, choice := range m.choices {
        cursor := "  "
        if m.cursor == i {
            cursor = "→ "
        }
        
        line := fmt.Sprintf("%s[%s] %s", cursor, choice.key, choice.label)
        if m.cursor == i {
            line = lipgloss.NewStyle().
                Foreground(lipgloss.Color("#729FCF")).
                Bold(true).
                Render(line)
        }
        b.WriteString(line + " - " + choice.description + "\n")
    }
    
    // 记住选择
    remember := "[ ] Remember this choice"
    if m.remember {
        remember = "[✓] Remember this choice"
    }
    b.WriteString("\n" + lipgloss.NewStyle().
        Foreground(lipgloss.Color("#888A85")).
        Render("[t] "+remember) + "\n")
    
    return b.String()
}
```

#### 2. `internal/config/config.go` (修改)

添加审批配置：

```go
type SecurityConfig struct {
    Readonly           bool           `toml:"readonly"`
    ConfirmDestructive bool           `toml:"confirm_destructive"`
    Approval           ApprovalConfig `toml:"approval"`  // 新增
}

// ApprovalConfig 审批系统配置
type ApprovalConfig struct {
    Enabled      bool     `toml:"enabled"`       // 启用审批系统
    DefaultLevel string   `toml:"default_level"` // 默认审批级别
    AutoApprove  []string `toml:"auto_approve"`  // 自动批准的工具
    ConfirmTools []string `toml:"confirm_tools"` // 必须确认的工具
}

func defaultConfig() Config {
    return Config{
        // ... 现有配置 ...
        Security: SecurityConfig{
            ConfirmDestructive: true,
            Approval: ApprovalConfig{
                Enabled:      true,
                DefaultLevel: "readonly",
                AutoApprove:  []string{"view", "list", "glob", "grep", "websearch"},
                ConfirmTools: []string{"edit", "shell"},
            },
        },
    }
}
```

#### 3. `internal/agent/agent.go` (修改)

在 Agent 中集成审批系统：

```go
type Agent struct {
    llm      *llm.LLM
    tools    *tool.Set
    approval *approval.Manager  // 新增
    maxSteps int
    mode     string
}

func New(l *llm.LLM, t *tool.Set, am *approval.Manager) *Agent {
    return &Agent{
        llm:      l,
        tools:    t,
        approval: am,
        maxSteps: config.C.MaxSteps,
        mode:     "default",
    }
}

func (a *Agent) runTools(ctx context.Context, calls []types.ToolCall, ch chan event.Event) []types.ToolResult {
    var results []types.ToolResult
    
    for _, tc := range calls {
        // 1. 发送工具开始事件
        ch <- event.Event{
            Type: event.ToolStart,
            Data: event.ToolStartData{
                ID:   tc.ID,
                Name: tc.Name,
                Args: tc.Args,
            },
        }
        
        // 2. 解析参数
        var args map[string]any
        if err := json.Unmarshal([]byte(tc.Args), &args); err != nil {
            a.sendToolEnd(ch, tc.ID, tc.Name, "", "invalid args")
            results = append(results, types.ToolResult{
                ToolCallID: tc.ID,
                Content:    "error: invalid args",
            })
            continue
        }
        
        // 3. 审批流程
        if a.approval != nil {
            resp, err := a.approval.Request(ctx, tc.Name, args)
            if err != nil {
                a.sendToolEnd(ch, tc.ID, tc.Name, "", "approval error: "+err.Error())
                results = append(results, types.ToolResult{
                    ToolCallID: tc.ID,
                    Content:    "error: approval failed",
                })
                continue
            }
            
            switch resp.Decision {
            case approval.DecisionReject:
                a.sendToolEnd(ch, tc.ID, tc.Name, "", "rejected by user")
                results = append(results, types.ToolResult{
                    ToolCallID: tc.ID,
                    Content:    "rejected by user",
                })
                continue
                
            case approval.DecisionEdit:
                // 使用用户编辑后的参数
                args = resp.EditedArgs
            }
        }
        
        // 4. 执行工具
        t := a.tools.Get(tc.Name)
        if t == nil {
            a.sendToolEnd(ch, tc.ID, tc.Name, "", "unknown tool")
            results = append(results, types.ToolResult{
                ToolCallID: tc.ID,
                Content:    "error: unknown tool",
            })
            continue
        }
        
        // 重新序列化参数（如果被编辑过）
        argsJSON, _ := json.Marshal(args)
        result, err := t.Run(ctx, json.RawMessage(argsJSON))
        
        // 5. 发送结果
        if err != nil {
            a.sendToolEnd(ch, tc.ID, tc.Name, "", err.Error())
            results = append(results, types.ToolResult{
                ToolCallID: tc.ID,
                Content:    "error: " + err.Error(),
            })
        } else {
            a.sendToolEnd(ch, tc.ID, tc.Name, result, "")
            results = append(results, types.ToolResult{
                ToolCallID: tc.ID,
                Content:    result,
            })
        }
    }
    
    return results
}
```

#### 4. `internal/tui/tui.go` (修改)

添加审批相关命令：

```go
// 新增命令处理
case "/approval":
    // 显示审批状态
    m.showApprovalStatus()
    
case "/trust":
    // 添加信任命令
    if len(parts) < 2 {
        m.messages = append(m.messages, message{
            role:    "system",
            content: "Usage: /trust <command_pattern>",
        })
    } else {
        pattern := strings.Join(parts[1:], " ")
        m.addTrustedPattern(pattern)
    }
    
case "/deny":
    // 添加拒绝命令
    if len(parts) < 2 {
        m.messages = append(m.messages, message{
            role:    "system",
            content: "Usage: /deny <command_pattern>",
        })
    } else {
        pattern := strings.Join(parts[1:], " ")
        m.addDeniedPattern(pattern)
    }
```

更新 help 命令：

```go
case "/help":
    help := `Commands:
  /new       Create new session
  /clear     Clear messages
  /sessions  List all sessions
  /switch    Switch session
  /models    List available models
  /model     Switch model
  /compact   Compact conversation history
  /context   Show current project context
  /projects  List all known projects
  /forget    Forget current project context
  /learn     Add topic to project context
  /approval  Show approval system status
  /trust     Add trusted command pattern (e.g., /trust "go test ./...")
  /deny      Add denied command pattern (e.g., /deny "rm -rf")
  /help      Show this help

Shortcuts:
   Enter     Send message
   Ctrl+J    New line
   Ctrl+C    Quit`
```

#### 5. `main.go` (修改)

初始化审批系统：

```go
func main() {
    // ... 现有初始化代码 ...
    
    // 初始化审批系统
    var approvalMgr *approval.Manager
    if config.C.Security.Approval.Enabled {
        policy := buildPolicyFromConfig()
        store := approval.NewStore(config.Home())
        ui := approval.NewBubbleTeaUI()
        approvalMgr = approval.NewManager(policy, store, ui)
    }
    
    // 创建 Agent（传入审批管理器）
    a := agent.New(llmClient, tools, approvalMgr)
    
    // ... 后续代码 ...
}

func buildPolicyFromConfig() *approval.Policy {
    c := config.C.Security.Approval
    
    toolLevels := make(map[string]approval.Level)
    for _, t := range c.AutoApprove {
        toolLevels[t] = approval.LevelAuto
    }
    for _, t := range c.ConfirmTools {
        toolLevels[t] = approval.LevelConfirm
    }
    
    return &approval.Policy{
        DefaultLevel: approval.LevelReadonly,
        ToolLevels:   toolLevels,
        ShellRules: []approval.ShellRule{
            {Pattern: `^git\s+status`, Level: approval.LevelAuto},
            {Pattern: `^git\s+log`, Level: approval.LevelAuto},
            {Pattern: `^git\s+diff`, Level: approval.LevelAuto},
            {Pattern: `^go\s+test`, Level: approval.LevelReadonly},
            {Pattern: `^rm\s+-rf`, Level: approval.LevelConfirm},
            {Pattern: `sudo`, Level: approval.LevelDeny},
        },
        TrustedCmds: []string{"go version", "pwd", "echo"},
        DeniedCmds:  []string{"rm -rf /", ":(){ :|:& };:"},
    }
}
```

---

## 接口设计

### TUI 命令

| 命令 | 功能 |
|------|------|
| `/approval` | 显示审批系统状态和配置 |
| `/trust <pattern>` | 添加信任命令模式 |
| `/deny <pattern>` | 添加拒绝命令模式 |
| `/approval reset` | 重置审批历史 |

### 配置项

```toml
[security]
readonly = false
confirm_destructive = true

[security.approval]
enabled = true
default_level = "readonly"
auto_approve = ["view", "list", "glob", "grep", "websearch", "webfetch"]
confirm_tools = ["edit", "shell"]

# Shell 命令审批规则
[[security.approval.shell_rules]]
pattern = "^git\\s+status"
level = "auto"

[[security.approval.shell_rules]]
pattern = "^rm\\s+-rf"
level = "confirm"
reason = "Destructive deletion"

[[security.approval.shell_rules]]
pattern = "sudo"
level = "deny"
reason = "Privileged operations not allowed"
```

### 环境变量

```bash
export OTTER_APPROVAL_ENABLED=1
export OTTER_APPROVAL_LEVEL=readonly  # auto, readonly, suggest, confirm
```

---

## 验收标准

### 功能测试

- [ ] 启用审批系统后，只读工具（view/list/grep）自动执行无需确认
- [ ] edit 工具调用时显示文件修改预览
- [ ] shell 工具调用时，危险命令（rm -rf）必须确认
- [ ] shell 工具调用时，安全命令（git status）自动执行
- [ ] 用户可以选择批准、拒绝或编辑工具调用
- [ ] 拒绝的操作不会执行，Agent 收到拒绝响应
- [ ] 审批历史正确保存，相同操作可自动处理
- [ ] `/trust` 命令可添加信任模式
- [ ] `/deny` 命令可添加拒绝模式
- [ ] `/approval` 显示当前配置和统计信息

### 边界测试

- [ ] 审批 UI 在流式输出模式下正常工作
- [ ] 用户取消审批（Ctrl+C）时优雅处理
- [ ] 损坏的配置文件可自动重置为默认
- [ ] 非 TUI 模式（如 headless）可禁用审批
- [ ] 审批超时后正确恢复

### 性能测试

- [ ] 风险评估 < 1ms
- [ ] 历史查询 < 5ms
- [ ] 审批 UI 渲染 < 16ms

### 代码质量

- [ ] 遵循 CLAUDE.md 代码风格
- [ ] 完整错误处理
- [ ] 单元测试覆盖率 > 70%
- [ ] 不引入重量级依赖

---

## 参考

### 相关项目

1. **Claude Code** - 权限确认系统
   - `--dangerously-skip-permissions` 标志
   - 对敏感操作的确认提示

2. **Aider** - 代码修改确认
   - 提交前确认修改
   - 批量操作的快捷确认

3. **Docker** - 权限管理
   - sudo 规则配置

### 技术文档

1. **Bubble Tea** - TUI 框架
   - https://github.com/charmbracelet/bubbletea

2. **正则表达式安全**
   - https://pkg.go.dev/regexp/syntax

### 代码参考

风险评估示例：
```go
func isDestructive(cmd string) bool {
    patterns := []string{
        `rm\s+-rf`,
        `sudo`,
        `mkfs`,
        `dd\s+if`,
        `>\s*/dev/`,
    }
    for _, p := range patterns {
        if matched, _ := regexp.MatchString(p, cmd); matched {
            return true
        }
    }
    return false
}
```

---

*PRD 版本: 1.0*  
*创建日期: 2025-02-10*  
*作者: otter-dev*
